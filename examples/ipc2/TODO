TODOs 


ThreadingModel as a Policy
==========================

 * SingleThreaded (as-is)
 * MultiThreaded (thread-pool) 
   * server side (skeletons)
   * client side (stubs)

   server side: requests are handled within a thread pool, the sockets are handled by the main thread, but
   all request handlers are called within the pool. Therefore, the requests are queued and the threads will
   take the requests in a FIFO order. For response dispatch we need a way back to the dispatcher since in 
   this case the thread may _never_ send anything blocking on any socket (in order to avoid event scattering
   on the wire).

   poll loop -------------> queue <------------- thread 1
               (request)      ^ ^
                              | +--------------- thread 2
                              +------------------thread 3

   thread x --------------> back-queue <----------- poll loop
              (response)                  

   The Stubs and Skeletons (-> Policy) thereby may be 
 
    * reentrant 
      -> we have nothing to be concerned about (just catch the event from the queue)

    * non-reentrant 
      -> the same server may not be called twice if it is already active in a thread
         * need activity flag
         * events may only be extracted from the queue if the corresponding stub is ready


Add further interaction device to event-loop
============================================

Add a generic fd based device to the dispatcher interface. This would be much easier if I base the whole
thing on top of the async IO framework.

Then, we can add further endpoints to the dispatcher to allow to handle also tcp based requests.


Tranport
========

Implement non-blocking write operations. In case of blocks queue the data and let the dispatcher
send the rest of it. The second variant can be used when clients call requests from other thread
contexts. One has to see if there is any state on clients side - if not, I can indeed trivially 
use clients in multithreaded environments. 

Servers are much more complex since they have some state during the answering process (currentRequest, 
currentSession, ...). In case of servers running within multiple threads we would need to store this
stuff in thread-local variables and have some locking on the dispatcher in order to access queues
and global data.


Error support
=============

How could an interface designer introduce other exception classes? Currently, I think
there is no need for this since either the user-defined exception is trivial or must again
be modeled like a complete response and therefore could just be a modeled as-so. The interface
designer could use any self-written enum to use this instead of the implementation used integer.


Transport error detection
=========================

Still missing. No concept yet.


Session support
===============

 * clients may send explicit detach calls to the server
 * maybe have handlers to be implemented to see if clients attach to a server 
 * Allow to send events to a certain client only (by adding the session_id
   of the client to the emit() call of the event. Any further functionality
   must be implemented by the user logic (e.g. how to register/unregister
   and when to send the event to a certain client).
   

Next Steps
==========

 Transport

 * introduce socket class with internal queue
 * if queue empty -> send directly nonblocking
 * if queue is full -> enqueue and arm fd slot for POLLOUT
 * if nonblocking send fails -> enqueue (the rest)

 ThreadingModel
 
 * mutex for dispatcher, must be used by all socket classes
   when sending data
 * receiving data only in one thread
